/*
 * (c) 2016-2020 Swirlds, Inc.
 *
 * This software is owned by Swirlds, Inc., which retains title to the software. This software is protected by various
 * intellectual property laws throughout the world, including copyright and patent laws. This software is licensed and
 * not sold. You must use this software only in accordance with the terms of the Hashgraph Open Review license at
 *
 * https://github.com/hashgraph/swirlds-open-review/raw/master/LICENSE.md
 *
 * SWIRLDS MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY OF THIS SOFTWARE, EITHER EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,
 * OR NON-INFRINGEMENT.
 */
package com.swirlds.platform;

import com.sun.management.OperatingSystemMXBean;
import com.swirlds.common.AddressBook;
import com.swirlds.common.NodeId;
import com.swirlds.common.PlatformStatNames;
import com.swirlds.common.StatEntry;
import com.swirlds.common.internal.AbstractStatistics;
import com.swirlds.platform.event.EventCounter;
import com.swirlds.platform.stats.ConsensusStats;

import java.io.File;
import java.lang.management.ManagementFactory;
import java.lang.management.ThreadMXBean;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static com.swirlds.common.PlatformStatNames.SIGNED_STATE_HASHING_TIME;

/**
 * This class collects and reports various statistics about network operation. A statistic such as
 * Transactions Per Second can be retrieved by using its name "trans/sec". The current list of statistic
 * names can be found by calling {@link #getAvailableStats}, and includes the following:
 *
 * <ul>
 * <li><b>badEv/sec</b> - number of corrupted events received per second *
 * <li><b>bytes/sec_sync</b> - average number of bytes per second transfered during a sync *
 * <li><b>bytes/sec_trans</b> - number of bytes in the transactions received per second (from unique events created
 * by self and others) *
 * <li><b>bytes/trans</b> - number of bytes in each transactions *
 * <li><b>cEvents/sec</b> - number of events per second created by this node *
 * <li><b>conns</b> - number of times a TLS connections was created *
 * <li><b>cpuLoadSys</b> - the CPU load of the whole system *
 * <li><b>dupEv%</b> - percentage of events received that are already known *
 * <li><b>ev/syncS</b> - number of events sent per successful sync *
 * <li><b>ev/syncR</b> - number of events received per successful sync *
 * <li><b>events/sec</b> - number of unique events received per second (created by self and others) *
 * <li><b>eventStreamQueueSize</b> - size of the queue from which we take events and write to EventStream file *
 * <li><b>icSync/sec</b> - (interrupted call syncs) syncs interrupted per second initiated by this member *
 * <li><b>irSync/sec</b> - (interrupted receive syncs) syncs interrupted per second initiated by other
 * member *
 * <li><b>lastSeq</b> - last event number generated by me *
 * <li><b>local</b> - number of members running on this local machine *
 * <li><b>memberID</b> - ID number of this member *
 * <li><b>members</b> - total number of members participating *
 * <li><b>memFree</b> - bytes of free memory (which can increase after a garbage collection) *
 * <li><b>memMax</b> - maximum bytes that the JVM might use *
 * <li><b>memTot</b> - total bytes in the Java Virtual Machine *
 * <li><b>name</b> - name of this member *
 * <li><b>ping</b> - average time for a round trip message between 2 computers (in milliseconds) *
 * <li><b>proc</b> - number of processors (cores) available to the JVM *
 * <li><b>roundSup</b> - latest round with state signed by a supermajority *
 * <li><b>rounds/sec</b> - average number of rounds per second *
 * <li><b>sec/sync</b> - duration of average successful sync (in seconds) *
 * <li><b>secC2C</b> - time from creating an event to knowing its consensus (in seconds) *
 * <li><b>SecC2H</b> - time from knowing consensus for a transaction to handling it (in seconds) *
 * <li><b>secC2R</b> - time from another member creating an event to receiving it and veryfing the signature
 * (in seconds) *
 * <li><b>secC2RC</b> - time from another member creating an event to it being received and and knowing
 * consensus for it (in seconds) *
 * <li><b>secR2C</b> - time from receiving an event to knowing its consensus (in seconds) *
 * <li><b>secR2F</b> - time from a round's first received event to all the famous witnesses being known (in
 * seconds) *
 * <li><b>secR2nR</b> - time from fist event received in one round, to first event received in the next
 * round (in seconds) *
 * <li><b>simListenSyncs</b> - avg number of simultaneous listening syncs happening at any given time *
 * <li><b>simSyncs</b> - avg number of simultaneous syncs happening at any given time *
 * <li><b>sync/secC</b> - (call syncs) syncs completed per second initiated by this member *
 * <li><b>sync/secR</b> - (receive syncs) syncs completed per second initiated by other member *
 * <li><b>threads</b> - the current number of live threads *
 * <li><b>time</b> - the current time *
 * <li><b>TLS</b> - 1 if using TLS, 0 if not *
 * <li><b>transCons</b> - transCons queue size *
 * <li><b>transEvent</b> - transEvent queue size *
 * <li><b>trans/event</b> - number of app transactions in each event *
 * <li><b>trans/sec</b> - number of app transactions received per second (from unique events created by self
 * and others) *
 * <li><b>write</b> - the app claimed to log statistics every this many milliseconds *
 * </ul>
 */
public class Statistics extends AbstractStatistics implements ConsensusStats {

	/** which Platform to watch */
	protected AbstractPlatform platform;
	/** an object used to get OS stats */
	private OperatingSystemMXBean osBean;

	/** an object to get thread stats */
	ThreadMXBean thbean;

	/** number of app transactions (from self and others) per second */
	StatsSpeedometer transactionsPerSecond;
	/** number of events (from self and others) per second */
	StatsSpeedometer eventsPerSecond;
	/** number of rounds reaching consensus per second */
	StatsSpeedometer roundsPerSecond;
	/** number of events discarded because already known */
	StatsSpeedometer duplicateEventsPerSecond;
	/** number of events discarded for bad sequence number / signature */
	StatsSpeedometer badEventsPerSecond;
	/** number of syncs per second that complete, where self called someone else */
	StatsSpeedometer callSyncsPerSecond;
	/** number of syncs per second that complete, where someone else called self */
	StatsSpeedometer recSyncsPerSecond;
	/** number of syncs initiated by member interrupted in the middle, per second */
	StatsSpeedometer interruptedCallSyncsPerSecond;
	/** number of syncs initiated by others interrupted in the middle, per second */
	StatsSpeedometer interruptedRecSyncsPerSecond;
	/** number of events created by this node per second */
	StatsSpeedometer eventsCreatedPerSecond;
	/**
	 * number of bytes in the transactions received per second (from unique events created by self and
	 * others)
	 */
	StatsSpeedometer bytesPerSecondTrans;
	/** number of bytes sent per second over the network (total for this member) */
	StatsSpeedometer bytesPerSecondSent;
	/** number of extra bytes sent per second to help other members who fall behind to catch up */
	StatsSpeedometer bytesPerSecondCatchupSent;
	/** time for event, from when the event is received, to when all the famous witnesses are known */
	StatsRunningAverage avgReceivedFamousTime;
	/** time for member, from creating to knowing consensus */
	StatsRunningAverage avgCreatedConsensusTime;
	/** time for a member, from receiving to knowing consensus */
	StatsRunningAverage avgReceivedConsensusTime;
	/** time for a member, from knowing consensus to handling that consensus transaction */
	StatsRunningAverage avgConsHandleTime;
	/** average wall clock time from start of a successful sync until it's done */
	StatsRunningAverage avgSyncDuration;
	/** average wall clock time for step 1 of a successful sync */
	StatsRunningAverage avgSyncDuration1;
	/** average wall clock time for step 2 of a successful sync */
	StatsRunningAverage avgSyncDuration2;
	/** average wall clock time for step 3 of a successful sync */
	StatsRunningAverage avgSyncDuration3;
	/** average wall clock time for step 4 of a successful sync */
	StatsRunningAverage avgSyncDuration4;
	/** average time (in seconds) to send a byte and get a reply, for each member (holds 0 for self) */
	StatsRunningAverage[] avgPingMilliseconds;
	/** average bytes per second received during a sync with each member (holds 0 for self) */
	StatsSpeedometer[] avgBytePerSecSent;
	/** time for event, from being created to being received by another member */
	StatsRunningAverage avgCreatedReceivedTime;
	/** time for event, from being created by one, to knowing consensus by another */
	StatsRunningAverage avgCreatedReceivedConsensusTime;
	/** time for event, from receiving the first event in a round to the first event in the next round */
	StatsRunningAverage avgFirstEventInRoundReceivedTime;
	/** average number of app transactions per event, counting both system and non-system transactions */
	StatsRunningAverage avgTransactionsPerEvent;
	/** average number of bytes per app transaction, counting both system and non-system transactions */
	StatsRunningAverage avgBytesPerTransaction;
	/** average percentage of received events that are already known */
	StatsRunningAverage avgDuplicatePercent;
	/** self event consensus timestamp minus time created */
	StatsRunningAverage avgSelfCreatedTimestamp;
	/** other event consensus timestamp minus time received */
	StatsRunningAverage avgOtherReceivedTimestamp;
	/** INTERNAL: number of app transactions (from self and others) per second */
	StatsSpeedometer transactionsPerSecondSys;
	/**
	 * INTERNAL: number of bytes in system transactions received per second, both created by self and
	 * others, only counting unique events
	 */
	StatsSpeedometer bytesPerSecondSys;
	/**
	 * INTERNAL: average number of system transactions per event, counting both system and non-system
	 * transactions
	 */
	StatsRunningAverage avgTransactionsPerEventSys;
	/**
	 * INTERNAL: average number of bytes per system transaction, counting both system and non-system
	 * transactions
	 */
	StatsRunningAverage avgBytesPerTransactionSys;
	/** sleeps per second because caller thread had too many failed connects */
	StatsSpeedometer sleep1perSecond;
	/** sleeps per second because listener thread had a closed socket */
	StatsSpeedometer sleep2perSecond;
	/** sleeps per second because server thread failed to bind to a port */
	StatsSpeedometer sleep3perSecond;
	/** fraction of syncs that are slowed to let others catch up */
	StatsRunningAverage fracSyncSlowed;
	/** fraction of each second spent in dot products */
	StatsSpeedometer timeFracDot;
	/** fraction of each second spent adding an event to the hashgraph, and calculating consensus */
	StatsSpeedometer timeFracAdd;
	/** average number of bytes per second transfered during a sync */
	StatsRunningAverage avgBytesPerSecSync;

	/** number of consensus transactions per second handled by SwirldState.handleTransaction() */
	StatsSpeedometer transHandledPerSecond;
	/** avg time to handle a consensus transaction in SwirldState.handleTransaction (in seconds) */
	StatsRunningAverage avgSecTransHandled;
	/** average time it takes the copy() method in SwirldState to finish (in seconds) */
	StatsRunningAverage avgSecStateCopy;
	/** average time it takes to create a new SignedState (in seconds) */
	StatsRunningAverage avgSecNewSignedState;

	/** boolean result of function {@link SyncManager#shouldCreateEvent(NodeId, boolean, int, int)} */
	StatsRunningAverage shouldCreateEvent;

	/** number of coin rounds that have occurred so far */
	StatsRunningAverage numCoinRounds;


	//////////////////// these are updated in Statistics.updateOthers() ///////////////

	/** number of app transactions received so far */
	StatsRunningAverage numTrans;
	/** average time for a round trip message between 2 computers (in milliseconds) */
	StatsRunningAverage avgPing;
	/** number of connections created (both calling and listening) */
	StatsRunningAverage avgConnsCreated;
	/** number of discarded events requested during syncs */
	StatsRunningAverage avgDiscEvReq;
	/** bytes of free memory (which can increase after a garbage collection) */
	StatsRunningAverage memFree;
	/** total bytes in the Java Virtual Machine */
	StatsRunningAverage memTot;
	/** maximum bytes that the JVM might use */
	StatsRunningAverage memMax;
	/** number of processors (cores) available to the JVM */
	StatsRunningAverage avgNumProc;
	/** the CPU load of the whole system */
	StatsRunningAverage cpuLoadSys;
	/** Total number of thread running */
	StatsRunningAverage threads;
	/** ID number of this member */
	StatsRunningAverage avgSelfId;
	/** total number of members participating */
	StatsRunningAverage avgNumMembers;
	/** number of members running on this local machine */
	StatsRunningAverage avgNumLocal;
	/** statistics are logged every this many milliseconds */
	StatsRunningAverage avgWrite;
	/** max number of syncs this can initiate simultaneously */
	StatsRunningAverage avgSimCallSyncsMax;
	/** avg number of syncs this member is doing simultaneously */
	StatsRunningAverage avgSimSyncs;
	/** avg number of listening syncs this member is doing simultaneously */
	StatsRunningAverage avgSimListenSyncs;
	/** number of non-consensus events waiting to be handled [forCurr.size()] */
	StatsRunningAverage avgQ1forCurr;
	/** number of consensus events waiting to be handled [forCons.size()] */
	StatsRunningAverage avgQ2forCons;
	/** number of handled events waiting to be deleted [forSigs.size()] */
	StatsRunningAverage avgQ3forSigs;
	/** number of events received waiting to be processed, or events waiting to be created [forSigs.size()] */
	StatsRunningAverage avgQ4forHash;
	/** size of the queue from which we take events and write to EventStream file */
	StatsRunningAverage eventStreamQueueSize;
	/** latest round with signed state by a supermajority */
	StatsRunningAverage avgRoundSupermajority;
	/** number of events sent per successful sync */
	StatsRunningAverage avgEventsPerSyncSent;
	/** number of events received per successful sync */
	StatsRunningAverage avgEventsPerSyncRec;
	/** INTERNAL: total number of events in memory, for all members on the local machine together */
	StatsRunningAverage avgEventsInMem;
	/** running average of the number of signatures collected on each signed state */
	StatsRunningAverage avgStateSigs;

	/** number of stale events per second */
	StatsSpeedometer staleEventsPerSecond;
	/** number of events generated per second to rescue childless events so they don't become stale */
	StatsSpeedometer rescuedEventsPerSecond;

	File rootDirectory = new File("/");
	long freeDiskspace = rootDirectory.getFreeSpace();
	long totalDiskspace = rootDirectory.getTotalSpace();

	/** once a second, update all the statistics that aren't updated by any other class */
	@Override
	public void updateOthers() {
		try {
			// don't update anything until the platform creates the hashgraph
			if (platform.getHashgraph() != null) {

				// calculate the value for otherStatPing (the average of all, not including self)
				double sum = 0;
				double[] times = getPingMilliseconds(); // times are in seconds
				for (double time : times) {
					sum += time;
				}
				// don't average in the times[selfId]==0, so subtract 1 from the length
				double pingValue = sum / (times.length - 1);  // pingValue is in milliseconds

				avgPing.recordValue(pingValue);
				interruptedCallSyncsPerSecond.update(0);
				interruptedRecSyncsPerSecond.update(0);
				badEventsPerSecond.update(0);
				platform.getStats().sleep1perSecond.update(0);
				platform.getStats().sleep2perSecond.update(0);
				platform.getStats().sleep3perSecond.update(0);
				numTrans.recordValue(platform.getHashgraph().getNumTrans());
				memFree.recordValue(Runtime.getRuntime().freeMemory());
				memTot.recordValue(Runtime.getRuntime().totalMemory());
				memMax.recordValue(Runtime.getRuntime().maxMemory());
				avgNumProc.recordValue(
						Runtime.getRuntime().availableProcessors());
				cpuLoadSys.recordValue(osBean.getSystemCpuLoad());
				threads.recordValue(thbean.getThreadCount());
				avgSelfId.recordValue(platform.getSelfId().getId());
				avgNumMembers.recordValue(
						platform.getHashgraph().getAddressBook().getSize());
				avgNumLocal.recordValue(
						platform.getHashgraph().getAddressBook().getOwnHostCount());
				avgWrite.recordValue(statsWritePeriod);
				avgSimCallSyncsMax.recordValue(Settings.maxOutgoingSyncs);
				avgSimSyncs.recordValue(platform.getSyncServer().numSyncs.get());
				avgSimListenSyncs.recordValue(platform.getSyncServer().numListenerSyncs.get());
				avgQ1forCurr.recordValue(platform.getEventFlow().getForCurrSize());
				avgQ2forCons.recordValue(platform.getEventFlow().getForConsSize());
				avgQ3forSigs.recordValue(platform.getEventFlow().getForSigsSize());
				eventStreamQueueSize.recordValue(platform.getRunningHashCalculator().getForStreamSize());

				avgQ4forHash.recordValue(platform.getHashgraph().getEventIntakeQueueSize());
				avgRoundSupermajority.recordValue(
						platform.getSignedStateManager().getLastCompleteRound());
				avgEventsInMem.recordValue(EventCounter.getNumEventsInMemory());
				if (platform != null && platform.getSyncServer() != null
						&& platform.getSyncClient() != null) {
					bytesPerSecondSent.update(
							platform.getSyncServer().getBytesWrittenSinceLast() // written by listeners
									+ platform.getSyncClient().getBytesWrittenSinceLast() // written by callers
					);
					avgConnsCreated.recordValue(
							platform.getSyncServer().connsCreated.get());
					avgDiscEvReq.recordValue(
							platform.getSyncServer().discardedEventsRequested.get());
				}
				freeDiskspace = rootDirectory.getFreeSpace();
			}
		} catch (Exception e) {
			// ignore exceptions
		}
	}

	/**
	 * Do not allow instantiation without knowing which Platform to monitor. Do not call this.
	 */
	@SuppressWarnings("unused")
	Statistics() {
		super();
		throw new UnsupportedOperationException(
				"called constructor new Statistics() instead of new Statistics(platform)");
	}

	/**
	 * Constructor for a Statistics object that will monitor the statistics for the network for the given
	 * Platform.
	 *
	 * @param platform
	 * 		the Platform whose statistics should be monitored
	 */
	public Statistics(AbstractPlatform platform) {
		super();
		this.platform = platform;
		this.osBean = (OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean();
		this.thbean = ManagementFactory.getThreadMXBean();
		int abSize = platform.getAddressBook() == null ? 0 : platform.getAddressBook().getSize(); //0 during unit tests

		avgPingMilliseconds = new StatsRunningAverage[abSize];
		avgBytePerSecSent = new StatsSpeedometer[abSize];
		for (int i = 0; i < avgPingMilliseconds.length; i++) {
			avgPingMilliseconds[i] = new StatsRunningAverage(Settings.halfLife);
		}
		for (int i = 0; i < avgBytePerSecSent.length; i++) {
			avgBytePerSecSent[i] = new StatsSpeedometer(Settings.halfLife);
		}
		createStatEntriesArray(platform);
		setUpStatEntries();
	}

	/**
	 * reset all the Speedometer and RunningAverage objects with a half life of Platform.halfLife
	 */
	@Override
	public void resetAllSpeedometers() {
		super.resetAllSpeedometers();

		for (StatsRunningAverage avgPingSecond : avgPingMilliseconds) {
			avgPingSecond.reset(Settings.halfLife);
		}
		for (StatsSpeedometer abpss : avgBytePerSecSent) {
			abpss.reset(Settings.halfLife);
		}
	}

	/**
	 * Returns the time for a round-trip message to each member (in milliseconds).
	 * <p>
	 * This is an exponentially-weighted average of recent ping times.
	 *
	 * @return the average times, for each member, in milliseconds
	 */
	public double[] getPingMilliseconds() {
		double[] times = new double[avgPingMilliseconds.length];
		for (int i = 0; i < times.length; i++) {
			times[i] = avgPingMilliseconds[i].getWeightedMean();
		}
		times[platform.getSelfId().getIdAsInt()] = 0;
		return times;
	}

	/**
	 * Returns the bytes per second received from each member during a sync. This is an
	 * exponentially-weighted average of recent throughput measurements. Throughput is the total number of
	 * bytes received during a sync, divided by the total time of the sync.
	 * <p>
	 * This is an exponentially-weighted average of recent measurements. The caller must NOT modify the
	 * array, nor call methods to modify the objects in it.
	 *
	 * @return the object for bytes per second for each member (null for self)
	 */
	StatsSpeedometer[] getBytePerSecs() {
		return avgBytePerSecSent;
	}

	/**
	 * return an array of info about all the statistics
	 *
	 * @return the array of StatEntry elements for every statistic managed by this class
	 */
	@Override
	public StatEntry[] getStatEntriesArray() {
		return statEntries;
	}

	/**
	 * Create all the data for the statEntry array. This must be called before getStatEntriesArray
	 */
	private void createStatEntriesArray(AbstractPlatform platform) {
		statEntries = new StatEntry[] {//
				new StatEntry(//
						INFO_CATEGORY,//
						"time",//
						"the current time",//
						"%25s",//
						null,//
						null,//
						null,//
						() -> DateTimeFormatter
								.ofPattern("yyyy-MM-dd HH:mm:ss z")
								.format(Instant.now()
										.atZone(ZoneId.of("UTC")))),
				new StatEntry(//
						INTERNAL_CATEGORY,//
						"trans",//
						"number of transactions received so far",//
						"%,13.0f",//
						numTrans,//
						(h) -> numTrans = new StatsRunningAverage(h),//
						null,//
						() -> numTrans.getWeightedMean()),//
				new StatEntry(//
						CATEGORY,//
						"secR2C",//
						"time from receiving an event to knowing its consensus (in seconds)",//
						"%,10.3f",//
						avgReceivedConsensusTime,//
						(h) -> {
							avgReceivedConsensusTime = new StatsRunningAverage(h);
							return avgReceivedConsensusTime;
						},//
						null,//
						() -> avgReceivedConsensusTime.getWeightedMean()),//
				new StatEntry(//
						CATEGORY,//
						"secC2C",//
						"time from creating an event to knowing its consensus (in seconds)",//
						"%,10.3f",//
						avgCreatedConsensusTime,//
						(h) -> {
							avgCreatedConsensusTime = new StatsRunningAverage(h);
							return avgCreatedConsensusTime;
						},//
						null,//
						() -> avgCreatedConsensusTime.getWeightedMean()),//
				new StatEntry(//
						CATEGORY,//
						"SecC2H",//
						"time from knowing consensus for a transaction to handling it (in seconds)",//
						"%,10.3f",//
						avgConsHandleTime,//
						(h) -> {
							avgConsHandleTime = new StatsRunningAverage(h);
							return avgConsHandleTime;
						},//
						null,//
						() -> avgConsHandleTime.getWeightedMean()),//
				new StatEntry(//
						CATEGORY,//
						"sec/sync",//
						"duration of average successful sync (in seconds)",//
						"%,10.3f",//
						avgSyncDuration,//
						(h) -> {
							avgSyncDuration = new StatsRunningAverage(h);
							return avgSyncDuration;
						},//
						null,//
						() -> avgSyncDuration.getWeightedMean()),//
				new StatEntry(//
						INTERNAL_CATEGORY,//
						"sec/sync1",//
						"duration of step 1 of average successful sync (in seconds)",//
						"%,10.3f",//
						avgSyncDuration1,//
						(h) -> {
							avgSyncDuration1 = new StatsRunningAverage(h);
							return avgSyncDuration1;
						},//
						null,//
						() -> avgSyncDuration1.getWeightedMean()),//
				new StatEntry(//
						INTERNAL_CATEGORY,//
						"sec/sync2",//
						"duration of step 2 of average successful sync (in seconds)",//
						"%,10.3f",//
						avgSyncDuration2,//
						(h) -> {
							avgSyncDuration2 = new StatsRunningAverage(h);
							return avgSyncDuration2;
						},//
						null,//
						() -> avgSyncDuration2.getWeightedMean()),//
				new StatEntry(//
						INTERNAL_CATEGORY,//
						"sec/sync3",//
						"duration of step 3 of average successful sync (in seconds)",//
						"%,10.3f",//
						avgSyncDuration3,//
						(h) -> {
							avgSyncDuration3 = new StatsRunningAverage(h);
							return avgSyncDuration3;
						},//
						null,//
						() -> avgSyncDuration3.getWeightedMean()),//
				new StatEntry(//
						INTERNAL_CATEGORY,//
						"sec/sync4",//
						"duration of step 4 of average successful sync (in seconds)",//
						"%,10.3f",//
						avgSyncDuration4,//
						(h) -> {
							avgSyncDuration4 = new StatsRunningAverage(h);
							return avgSyncDuration4;
						},//
						null,//
						() -> avgSyncDuration4.getWeightedMean()),//
				new StatEntry(//
						CATEGORY,//
						"rounds/sec",//
						"average number of rounds per second",//
						"%,11.3f",//
						roundsPerSecond,//
						(h) -> {
							roundsPerSecond = new StatsSpeedometer(h);
							return roundsPerSecond;
						},//
						null,//
						() -> roundsPerSecond.getCyclesPerSecond()),//
				new StatEntry(//
						CATEGORY,//
						"ping",//
						"average time for a round trip message between 2 computers (in milliseconds)",//
						"%,7.0f",//
						avgPing,//
						(h) -> {
							avgPing = new StatsRunningAverage(h);
							return avgPing;
						},//
						null,//
						() -> avgPing.getWeightedMean()),//
				new StatEntry(//
						CATEGORY,//
						"bytes/sec_trans",//
						"number of bytes in the transactions received per second (from unique events created " + //
								"by self and others)", //
						"%,16.2f",//
						bytesPerSecondTrans,//
						(h) -> {
							bytesPerSecondTrans = new StatsSpeedometer(h);
							return bytesPerSecondTrans;
						},//
						null,//
						() -> bytesPerSecondTrans.getCyclesPerSecond()),//
				new StatEntry(//
						INTERNAL_CATEGORY,//
						"bytes/sec_sent",//
						"number of bytes sent per second over the network (total for this member)",//
						"%,16.2f",//
						bytesPerSecondSent,//
						(h) -> {
							bytesPerSecondSent = new StatsSpeedometer(6 * h);
							return bytesPerSecondSent;
						},//
						(h) -> bytesPerSecondSent.reset(6 * h),//
						() -> bytesPerSecondSent.getCyclesPerSecond()),//
				new StatEntry(//
						INTERNAL_CATEGORY,//
						"bytes/sec_catchup",//
						"number of bytes sent per second to help others catch up",//
						"%,16.2f",//
						bytesPerSecondCatchupSent,//
						(h) -> {
							bytesPerSecondCatchupSent = new StatsSpeedometer(h);
							return bytesPerSecondCatchupSent;
						},//
						null,//
						() -> bytesPerSecondCatchupSent.getCyclesPerSecond()),//
				new StatEntry(//
						INTERNAL_CATEGORY,//
						"bytes/sec_sys",//
						"number of bytes in the system transactions received per second (from unique events " +
								"created by self and others)",
//
						"%,16.2f",//
						bytesPerSecondSys,//
						(h) -> {
							bytesPerSecondSys = new StatsSpeedometer(h);
							return bytesPerSecondSys;
						},//
						null,//
						() -> bytesPerSecondSys.getCyclesPerSecond()),//
				new StatEntry(//
						CATEGORY,//
						"trans/sec",//
						"number of app transactions received per second (from unique events created by self and " +
								"others)",
//
						"%,13.2f",//
						transactionsPerSecond,//
						(h) -> {
							transactionsPerSecond = new StatsSpeedometer(h);
							return transactionsPerSecond;
						},//
						null,//
						() -> transactionsPerSecond.getCyclesPerSecond()),//
				new StatEntry(//
						CATEGORY,//
						"events/sec",//
						"number of unique events received per second (created by self and others)",//
						"%,16.2f",//
						eventsPerSecond,//
						(h) -> {
							eventsPerSecond = new StatsSpeedometer(h);
							return eventsPerSecond;
						},//
						null,//
						() -> eventsPerSecond.getCyclesPerSecond()),// },//
				new StatEntry(//
						INTERNAL_CATEGORY,//
						"dupEv/sec",//
						"number of events received per second that are already known",//
						"%,14.2f",//
						duplicateEventsPerSecond,//
						(h) -> {
							duplicateEventsPerSecond = new StatsSpeedometer(h);
							return duplicateEventsPerSecond;
						},//
						null,//
						() -> duplicateEventsPerSecond.getCyclesPerSecond()),//
				new StatEntry(//
						CATEGORY,//
						"dupEv%",//
						"percentage of events received that are already known",//
						"%,10.2f",//
						avgDuplicatePercent,//
						(h) -> {
							avgDuplicatePercent = new StatsRunningAverage(h);
							return avgDuplicatePercent;
						},//
						null,//
						() -> avgDuplicatePercent.getWeightedMean()),//
				new StatEntry(//
						CATEGORY,//
						"badEv/sec",//
						"number of corrupted events received per second",//
						"%,14.7f",//
						badEventsPerSecond,//
						(h) -> {
							badEventsPerSecond = new StatsSpeedometer(h);
							return badEventsPerSecond;
						},//
						null,//
						() -> badEventsPerSecond.getCyclesPerSecond()),//
				new StatEntry(//
						CATEGORY,//
						"sync/secC",//
						"(call syncs) syncs completed per second initiated by this member",//
						"%,14.7f",//
						callSyncsPerSecond,//
						(h) -> {
							callSyncsPerSecond = new StatsSpeedometer(h);
							return callSyncsPerSecond;
						},//
						null,//
						() -> callSyncsPerSecond.getCyclesPerSecond()),//
				new StatEntry(//
						CATEGORY,//
						"sync/secR",//
						"(receive syncs) syncs completed per second initiated by other member",//
						"%,14.7f",//
						recSyncsPerSecond,//
						(h) -> {
							recSyncsPerSecond = new StatsSpeedometer(h);
							return recSyncsPerSecond;
						},//
						null,//
						() -> recSyncsPerSecond.getCyclesPerSecond()),//
				new StatEntry(//
						CATEGORY,//
						"icSync/sec",//
						"(interrupted call syncs) syncs interrupted per second initiated by this member",//
						"%,14.7f",//
						interruptedCallSyncsPerSecond,//
						(h) -> {
							interruptedCallSyncsPerSecond = new StatsSpeedometer(h);
							return interruptedCallSyncsPerSecond;
						},//
						null,//
						() -> interruptedCallSyncsPerSecond
								.getCyclesPerSecond()),//
				new StatEntry(//
						CATEGORY,//
						"irSync/sec",//
						"(interrupted receive syncs) syncs interrupted per second initiated by other member",//
						"%,14.7f",//
						interruptedRecSyncsPerSecond,//
						(h) -> {
							interruptedRecSyncsPerSecond = new StatsSpeedometer(h);
							return interruptedRecSyncsPerSecond;
						},//
						null,//
						() -> interruptedRecSyncsPerSecond
								.getCyclesPerSecond()),//
				new StatEntry(//
						CATEGORY,//
						"memFree",//
						"bytes of free memory (which can increase after a garbage collection)",//
						"%,16.0f",//
						memFree,//
						(h) -> {
							memFree = new StatsRunningAverage(0);
							return memFree;
						},// zero lambda for no smoothing
						(h) -> memFree.reset(0),// zero lambda for no smoothing
						() -> memFree.getWeightedMean()),//
				new StatEntry(//
						CATEGORY,//
						"memTot",//
						"total bytes in the Java Virtual Machine",//
						"%,16.0f",//
						memTot,//
						(h) -> {
							memTot = new StatsRunningAverage(0);
							return memTot;
						},// zero lambda for no smoothing
						(h) -> memTot.reset(0),// zero lambda for no smoothing
						() -> memTot.getWeightedMean()),//
				new StatEntry(//
						CATEGORY,//
						"memMax",//
						"maximum bytes that the JVM might use",//
						"%,16.0f",//
						memMax,//
						(h) -> {
							memMax = new StatsRunningAverage(0);
							return memMax;
						},// zero lambda for no smoothing
						(h) -> memMax.reset(0),// zero lambda for no smoothing
						() -> memMax.getWeightedMean()),//
				new StatEntry(//
						CATEGORY,//
						"proc",//
						"number of processors (cores) available to the JVM",//
						"%,8.0f",//
						avgNumProc,//
						(h) -> {
							avgNumProc = new StatsRunningAverage(h);
							return avgNumProc;
						},//
						null,//
						() -> avgNumProc.getWeightedMean()),//
				new StatEntry(//
						CATEGORY,//
						"cpuLoadSys",//
						"the CPU load of the whole system",//
						"%,1.4f",//
						cpuLoadSys,//
						(h) -> {
							cpuLoadSys = new StatsRunningAverage(h);
							return cpuLoadSys;
						},//
						null,//
						() -> cpuLoadSys.getWeightedMean()),//
				new StatEntry(//
						CATEGORY,//
						"threads",//
						"the current number of live threads",//
						"%,6.0f",//
						threads,//
						(h) -> {
							threads = new StatsRunningAverage(h);
							return threads;
						},//
						null,//
						() -> threads.getWeightedMean()),//
				new StatEntry(//
						INFO_CATEGORY,//
						"name",//
						"name of this member",//
						"%8s",//
						null,//
						null,//
						null,//
						() -> {
							if (platform.isMirrorNode()) {
								return "Mirror-" + platform.getSelfId().getId();
							}
							return platform.getHashgraph().getAddressBook()
									.getAddress(platform.getSelfId().getId())
									.getSelfName();
						}),//
				new StatEntry(//
						INFO_CATEGORY,//
						"memberID",//
						"ID number of this member",//
						"%3.0f",//
						avgSelfId,//
						(h) -> {
							avgSelfId = new StatsRunningAverage(h);
							return avgSelfId;
						},//
						null,//
						() -> avgSelfId.getWeightedMean()),//
				new StatEntry(//
						CATEGORY,//
						"members",// //
						"total number of members participating",//
						"%,10.0f",//
						avgNumMembers,//
						(h) -> {
							avgNumMembers = new StatsRunningAverage(h);
							return avgNumMembers;
						},//
						null,//
						() -> avgNumMembers.getWeightedMean()),//
				new StatEntry(//
						CATEGORY,//
						"local",// //
						"number of members running on this local machine",//
						"%,8.0f",//
						avgNumLocal,//
						(h) -> {
							avgNumLocal = new StatsRunningAverage(h);
							return avgNumLocal;
						},//
						null,//
						() -> avgNumLocal.getWeightedMean()),//
				new StatEntry(//
						CATEGORY,//
						"write",// //
						"the app claimed to log statistics every this many milliseconds",//
						"%,8.0f",//
						avgWrite,//
						(h) -> {
							avgWrite = new StatsRunningAverage(h);
							return avgWrite;
						},//
						null,//
						() -> avgWrite.getWeightedMean()),//
				new StatEntry(//
						CATEGORY,//
						"bytes/trans",// //
						"number of bytes in each transactions",//
						"%,16.0f",//
						avgBytesPerTransaction,//
						(h) -> {
							avgBytesPerTransaction = new StatsRunningAverage(h);
							return avgBytesPerTransaction;
						},//
						null,//
						() -> avgBytesPerTransaction.getWeightedMean()),//
				new StatEntry(//
						CATEGORY,//
						"trans/event",// //
						"number of app transactions in each event",//
						"%,17.1f",//
						avgTransactionsPerEvent,//
						(h) -> {
							avgTransactionsPerEvent = new StatsRunningAverage(h);
							return avgTransactionsPerEvent;
						},//
						null,//
						() -> avgTransactionsPerEvent.getWeightedMean()),//
				new StatEntry(//
						INTERNAL_CATEGORY,//
						"simCallSyncsMax",// //
						"max number of syncs this can initiate simultaneously",//
						"%,2.0f",//
						avgSimCallSyncsMax,//
						(h) -> {
							avgSimCallSyncsMax = new StatsRunningAverage(h);
							return avgSimCallSyncsMax;
						},//
						null,//
						() -> avgSimCallSyncsMax.getWeightedMean()),//
				new StatEntry(//
						CATEGORY,//
						"simSyncs",// //
						"avg number of simultaneous syncs happening at any given time",//
						"%,9.6f",//
						avgSimSyncs,//
						(h) -> {
							avgSimSyncs = new StatsRunningAverage(h);
							return avgSimSyncs;
						},//
						null,//
						() -> avgSimSyncs.getWeightedMean()),//
				new StatEntry(//
						CATEGORY,//
						"simListenSyncs",// //
						"avg number of simultaneous listening syncs happening at any given time",//
						"%,9.6f",//
						avgSimListenSyncs,//
						(h) -> {
							avgSimListenSyncs = new StatsRunningAverage(h);
							return avgSimListenSyncs;
						},//
						null,//
						() -> avgSimListenSyncs.getWeightedMean()),//
				new StatEntry(//
						CATEGORY,//
						"cEvents/sec",//
						"number of events per second created by this node",//
						"%,16.2f",//
						eventsCreatedPerSecond,//
						(h) -> {
							eventsCreatedPerSecond = new StatsSpeedometer(h);
							return eventsCreatedPerSecond;
						},//
						null,//
						() -> eventsCreatedPerSecond.getCyclesPerSecond()),//
				new StatEntry(//
						CATEGORY,//
						"secC2R",//
						"time from another member creating an event to receiving it and veryfing the " + //
								"signature (in seconds)", //
						"%,10.3f",//
						avgCreatedReceivedTime,//
						(h) -> {
							avgCreatedReceivedTime = new StatsRunningAverage(h);
							return avgCreatedReceivedTime;
						},//
						null,//
						() -> avgCreatedReceivedTime.getWeightedMean()),//
				new StatEntry(//
						CATEGORY,//
						"secC2RC",//
						"time from another member creating an event to it being received and and knowing  " + //
								"consensus for it (in seconds)", //
						"%,10.3f",//
						avgCreatedReceivedConsensusTime,//
						(h) -> {
							avgCreatedReceivedConsensusTime = new StatsRunningAverage(h);
							return avgCreatedReceivedConsensusTime;
						},//
						null,//
						() -> avgCreatedReceivedConsensusTime
								.getWeightedMean()),//
				new StatEntry(//
						CATEGORY,//
						"secR2nR",//
						"time from first event received in one round, to first event received in the " + //
								"next round (in seconds)", //
						"%,10.3f",//
						avgFirstEventInRoundReceivedTime,//
						(h) -> {
							avgFirstEventInRoundReceivedTime = new StatsRunningAverage(h);
							return avgFirstEventInRoundReceivedTime;
						},//
						null,//
						() -> avgFirstEventInRoundReceivedTime
								.getWeightedMean()),//
				new StatEntry(//
						CATEGORY,//
						"secR2F",//
						"time from a round's first received event to all the famous witnesses being known (in seconds)",
						"%,10.3f",//
						avgReceivedFamousTime,//
						(h) -> {
							avgReceivedFamousTime = new StatsRunningAverage(h);
							return avgReceivedFamousTime;
						},//
						null,//
						() -> avgReceivedFamousTime.getWeightedMean()),//
				new StatEntry(//
						INTERNAL_CATEGORY,//
						"q1",//
						"number of non-consensus events in queue waiting to be handled",//
						"%,10.3f",//
						avgQ1forCurr,//
						(h) -> {
							avgQ1forCurr = new StatsRunningAverage(h);
							return avgQ1forCurr;
						},//
						null,//
						() -> avgQ1forCurr.getWeightedMean()),//
				new StatEntry(//
						INTERNAL_CATEGORY,//
						"q2",//
						"number of consensus events in queue waiting to be handled",//
						"%,10.3f",//
						avgQ2forCons,//
						(h) -> {
							avgQ2forCons = new StatsRunningAverage(h);
							return avgQ2forCons;
						},//
						null,//
						() -> avgQ2forCons.getWeightedMean()),//
				new StatEntry(//
						INTERNAL_CATEGORY,//
						"q3",//
						"number of handled events in queue waiting to be deleted",//
						"%,10.1f",//
						avgQ3forSigs,//
						(h) -> {
							avgQ3forSigs = new StatsRunningAverage(h);
							return avgQ3forSigs;
						},//
						null,//
						() -> avgQ3forSigs.getWeightedMean()),//
				new StatEntry(//
						INTERNAL_CATEGORY,//
						"q4",//
						"number events in receiving queue waiting to be processed or created",//
						"%,10.1f",//
						avgQ4forHash,//
						(h) -> {
							avgQ4forHash = new StatsRunningAverage(h);
							return avgQ4forHash;
						},//
						null,//
						() -> avgQ4forHash.getWeightedMean()),//
				new StatEntry(//
						CATEGORY,//
						"roundSup",//
						"latest round with state signed by a supermajority",//
						"%,10.0f",//
						avgRoundSupermajority,//
						(h) -> {
							avgRoundSupermajority = new StatsRunningAverage(h);
							return avgRoundSupermajority;
						},//
						null,//
						() -> avgRoundSupermajority.getWeightedMean()),//
				new StatEntry(//
						CATEGORY,//
						"ev/syncS",//
						"number of events sent per successful sync",//
						"%,8.1f",//
						avgEventsPerSyncSent,//
						(h) -> {
							avgEventsPerSyncSent = new StatsRunningAverage(h);
							return avgEventsPerSyncSent;
						},//
						null,//
						() -> avgEventsPerSyncSent.getWeightedMean()),//
				new StatEntry(//
						CATEGORY,//
						"ev/syncR",//
						"number of events received per successful sync",//
						"%,8.1f",//
						avgEventsPerSyncRec,//
						(h) -> {
							avgEventsPerSyncRec = new StatsRunningAverage(h);
							return avgEventsPerSyncRec;
						},//
						null,//
						() -> avgEventsPerSyncRec.getWeightedMean()),//
				new StatEntry(//
						INTERNAL_CATEGORY,//
						"secSC2T",//
						"self event consensus timestamp minus time created (in seconds)",//
						"%,10.3f",//
						avgSelfCreatedTimestamp,//
						(h) -> {
							avgSelfCreatedTimestamp = new StatsRunningAverage(h);
							return avgSelfCreatedTimestamp;
						},//
						null,//
						() -> avgSelfCreatedTimestamp.getWeightedMean()),//
				new StatEntry(//
						INTERNAL_CATEGORY,//
						"secOR2T",//
						"other event consensus timestamp minus time received (in seconds)",//
						"%,10.3f",//
						avgOtherReceivedTimestamp,//
						(h) -> {
							avgOtherReceivedTimestamp = new StatsRunningAverage(h);
							return avgOtherReceivedTimestamp;
						},//
						null,//
						() -> avgOtherReceivedTimestamp.getWeightedMean()),//
				new StatEntry(//
						INTERNAL_CATEGORY,//
						"eventsInMem",//
						"total number of events in memory, for all members on the local machine together",//
						"%,16.2f",//
						avgEventsInMem,//
						(h) -> {
							avgEventsInMem = new StatsRunningAverage(h);
							return avgEventsInMem;
						},//
						null,//
						() -> avgEventsInMem.getWeightedMean()),//
				new StatEntry(//
						INTERNAL_CATEGORY,//
						"trans/sec_sys",//
						"number of system transactions received per second (from unique events created by self and " +
								"others)",
//
						"%,13.2f",//
						transactionsPerSecondSys,//
						(h) -> {
							transactionsPerSecondSys = new StatsSpeedometer(h);
							return transactionsPerSecondSys;
						},//
						null,//
						() -> transactionsPerSecondSys.getCyclesPerSecond()),//
				new StatEntry(//
						INTERNAL_CATEGORY,//
						"bytes/trans_sys",// //
						"number of bytes in each system transaction",//
						"%,16.0f",//
						avgBytesPerTransactionSys,//
						(h) -> {
							avgBytesPerTransactionSys = new StatsRunningAverage(h);
							return avgBytesPerTransactionSys;
						},//
						null,//
						() -> avgBytesPerTransactionSys.getWeightedMean()),//
				new StatEntry(//
						INTERNAL_CATEGORY,//
						"trans/event_sys",// //
						"number of system transactions in each event",//
						"%,17.1f",//
						avgTransactionsPerEventSys,//
						(h) -> {
							avgTransactionsPerEventSys = new StatsRunningAverage(h);
							return avgTransactionsPerEventSys;
						},//
						null,//
						() -> avgTransactionsPerEventSys.getWeightedMean()),//
				new StatEntry(//
						CATEGORY,//
						"conns",//
						"number of times a TLS connections was created",//
						"%,10.0f",//
						avgConnsCreated,//
						(h) -> {
							avgConnsCreated = new StatsRunningAverage(0);
							return avgConnsCreated;
						},// no smoothing
						(h) -> avgConnsCreated.reset(0),// zero lambda for no smoothing
						() -> avgConnsCreated.getWeightedMean()),
				new StatEntry(//
						INTERNAL_CATEGORY,//
						"discEvReq",//
						"number of old discarded events requested during sync",//
						"%,10.0f",//
						avgDiscEvReq,//
						(h) -> {
							avgDiscEvReq = new StatsRunningAverage(0);
							return avgDiscEvReq;
						},// no smoothing
						(h) -> avgDiscEvReq.reset(0),// zero lambda for no smoothing
						() -> avgDiscEvReq.getWeightedMean()),
				new StatEntry(//
						INFO_CATEGORY,//
						"TLS",//
						"1 if using TLS, 0 if not",//
						"%6d",//
						null,//
						null,//
						null,//
						() -> Settings.useTLS ? 1 : 0),
				new StatEntry(//
						INTERNAL_CATEGORY,//
						"fracSyncSlowed",//
						"fraction of syncs that are slowed to let others catch up",//
						"%,9.6f",//
						fracSyncSlowed,//
						(h) -> {
							fracSyncSlowed = new StatsRunningAverage(h);
							return fracSyncSlowed;
						},//
						null,//
						() -> fracSyncSlowed.getWeightedMean()),
				new StatEntry(//
						INTERNAL_CATEGORY,//
						"timeFracDot",//
						"fraction of each second spent on dot products",//
						"%,9.6f",//
						timeFracDot,//
						(h) -> {
							timeFracDot = new StatsSpeedometer(h);
							return timeFracDot;
						},//
						null,//
						() -> timeFracDot.getCyclesPerSecond()),
				new StatEntry(//
						INTERNAL_CATEGORY,//
						"timeFracAdd",//
						"fraction of each second spent adding an event to the hashgraph and finding consensus",//
						"%,9.6f",//
						timeFracAdd,//
						(h) -> {
							timeFracAdd = new StatsSpeedometer(h);
							return timeFracAdd;
						},//
						null,//
						() -> timeFracAdd.getCyclesPerSecond()),
				new StatEntry(//
						INTERNAL_CATEGORY,//
						"sleep1/sec",//
						"sleeps per second because caller thread had too many failed connects",//
						"%,9.6f",//
						sleep1perSecond,//
						(h) -> {
							sleep1perSecond = new StatsSpeedometer(h);
							return sleep1perSecond;
						},//
						null,//
						() -> sleep1perSecond.getCyclesPerSecond()),
				new StatEntry(//
						INTERNAL_CATEGORY,//
						"sleep2/sec",//
						"sleeps per second because listener thread had a closed socket",//
						"%,9.6f",//
						sleep2perSecond,//
						(h) -> {
							sleep2perSecond = new StatsSpeedometer(h);
							return sleep2perSecond;
						},//
						null,//
						() -> sleep2perSecond.getCyclesPerSecond()),
				new StatEntry(//
						INTERNAL_CATEGORY,//
						"sleep3/sec",//
						"sleeps per second because server thread failed to bind to a port",//
						"%,9.6f",//
						sleep3perSecond,//
						(h) -> {
							sleep3perSecond = new StatsSpeedometer(h);
							return sleep3perSecond;
						},//
						null,//
						() -> sleep3perSecond.getCyclesPerSecond()),//
				new StatEntry(//
						INTERNAL_CATEGORY,//
						PlatformStatNames.TRANSACTIONS_HANDLED_PER_SECOND,//
						"number of consensus transactions per second handled by SwirldState.handleTransaction()",//
						"%,9.6f",//
						transHandledPerSecond,//
						(h) -> {
							transHandledPerSecond = new StatsSpeedometer(h);
							return transHandledPerSecond;
						},//
						null,//
						() -> transHandledPerSecond.getCyclesPerSecond()),//
				new StatEntry(//
						INTERNAL_CATEGORY,//
						"secTransH",//
						"avg time to handle a consensus transaction in SwirldState.handleTransaction (in seconds)",//
						"%,10.6f",//
						avgSecTransHandled,//
						(h) -> {
							avgSecTransHandled = new StatsRunningAverage(h);
							return avgSecTransHandled;
						},//
						null,//
						() -> avgSecTransHandled.getWeightedMean()),//
				new StatEntry(//
						INTERNAL_CATEGORY,//
						"secStateCopy",//
						"average time it takes the SwirldState.copy() method in SwirldState to finish (in seconds)",//
						"%,10.3f",//
						avgSecStateCopy,//
						(h) -> {
							avgSecStateCopy = new StatsRunningAverage(h);
							return avgSecStateCopy;
						},//
						null,//
						() -> avgSecStateCopy.getWeightedMean()),//
				new StatEntry(//
						INTERNAL_CATEGORY,//
						SIGNED_STATE_HASHING_TIME,//
						"average time it takes to create a new SignedState (in seconds)",//
						"%,10.3f",//
						avgSecNewSignedState,//
						(h) -> {
							avgSecNewSignedState = new StatsRunningAverage(h);
							return avgSecNewSignedState;
						},//
						null,//
						() -> avgSecNewSignedState.getWeightedMean()),//
				new StatEntry(//
						CATEGORY,//
						"bytes/sec_sync",//
						"average number of bytes per second transfered during a sync",//
						"%,16.2f",//
						avgBytesPerSecSync,//
						(h) -> {
							avgBytesPerSecSync = new StatsRunningAverage(h);
							return avgBytesPerSecSync;
						},//
						null,//
						() -> avgBytesPerSecSync.getWeightedMean()),//
				new StatEntry(//
						INTERNAL_CATEGORY,//
						"stateSigs",//
						"number of signatures collected on each signed state",//
						"%,10.2f",//
						avgStateSigs,//
						(h) -> {
							avgStateSigs = new StatsRunningAverage(h);
							return avgStateSigs;
						},//
						null,//
						() -> avgStateSigs.getWeightedMean()),//
				new StatEntry(//
						INTERNAL_CATEGORY,//
						"coinR",// //
						"number of coin rounds that have occurred so far",//
						"%,10.0f",//
						numCoinRounds,//
						(h) -> {
							numCoinRounds = new StatsRunningAverage(h);
							return numCoinRounds;
						},//
						null,//
						() -> numCoinRounds.getWeightedMean()),//

				new StatEntry(//
						INFO_CATEGORY,//
						"lastSeq",//
						"last event number generated by me",//
						"%d",//
						null,//
						null,//
						null,//
						() -> {
							if (platform.isMirrorNode()) {
								return -1;
							}
							return platform.getHashgraph().getLastSeq(platform.getSelfId().getId());
						}),//


				new StatEntry(//
						INFO_CATEGORY,//
						"transEvent",//
						"transEvent queue size",//
						"%d",//
						null,//
						null,//
						null,//
						() -> platform.getEventFlow() == null ? 0 :
								platform.getEventFlow().getTransLists().getEventSize()),//

				new StatEntry(//
						INFO_CATEGORY,//
						"transCons",//
						"transCons queue size",//
						"%d",//
						null,//
						null,//
						null,//
						() -> platform.getEventFlow() == null ? 0 :
								platform.getEventFlow().getTransLists().getConsSize()),//

				// Statistics for monitoring transaction and event creation logic

				new StatEntry(//
						INTERNAL_CATEGORY,//
						"isEvFrozen",//
						"isEventCreationFrozen",//
						"%b",//
						null,//
						null,//
						null,//
						() -> platform.getFreezeManager().isEventCreationFrozen()),//

				new StatEntry(//
						INTERNAL_CATEGORY,//
						"isStrongMinorityInMaxRound",//
						"isStrongMinorityInMaxRound",//
						"%b",//
						null,//
						null,//
						null,//
						() -> {
							if (platform.isMirrorNode()) {
								return false;
							}
							return platform.getHashgraph().isStrongMinorityInMaxRound(platform.getSelfId().getId());
						}),//

				new StatEntry(//
						INTERNAL_CATEGORY,//
						"transThrottleCallAndCreate",//
						"transThrottleCallAndCreate",//
						"%b",//
						null,//
						null,//
						null,//
						() -> platform.getSyncManager() == null ? 0 :
								platform.getSyncManager().transThrottleCallAndCreate()),//

				new StatEntry(//
						INTERNAL_CATEGORY,//
						"shouldAcceptSync",//
						"shouldAcceptSync",//
						"%b",//
						null,//
						null,//
						null,//
						() -> platform.getSyncManager() == null ? 0 : platform.getSyncManager().shouldAcceptSync()),//

				new StatEntry(//
						INTERNAL_CATEGORY,//
						"shouldInitiateSync",//
						"shouldInitiateSync",//
						"%b",//
						null,//
						null,//
						null,//
						() -> platform.getSyncManager() == null ? 0 : platform.getSyncManager().shouldInitiateSync()),//

				new StatEntry(//
						INTERNAL_CATEGORY,//
						"getNumUserTransEvents",//
						"getNumUserTransEvents",//
						"%d",//
						null,//
						null,//
						null,//
						() -> platform.getHashgraph().getNumUserTransEvents()),//


				new StatEntry(//
						INTERNAL_CATEGORY,//
						"hasFallenBehind",//
						"hasFallenBehind",//
						"%b",//
						null,//
						null,//
						null,//
						() -> platform.getSyncManager() == null ? 0 : platform.getSyncManager().hasFallenBehind()),//

				new StatEntry(//
						INTERNAL_CATEGORY,//
						"shouldCreateEvent",//
						"shouldCreateEvent",//
						"%,10.1f",//
						shouldCreateEvent,//
						(h) -> {
							shouldCreateEvent = new StatsRunningAverage(h);
							return shouldCreateEvent;
						},//
						null,//
						() -> shouldCreateEvent.getWeightedMean()),//

				new StatEntry(//
						INTERNAL_CATEGORY,//
						"numReportFallenBehind",//
						"numReportFallenBehind",//
						"%d",//
						null,//
						null,//
						null,//
						() -> platform.getSyncManager() == null ? 0 : platform.getSyncManager().numReportFallenBehind),//

				new StatEntry(//
						INTERNAL_CATEGORY,//
						"staleEv/sec",//
						"number of stale events per second",//
						"%,16.2f",//
						staleEventsPerSecond,//
						(h) -> {
							staleEventsPerSecond = new StatsSpeedometer(h);
							return staleEventsPerSecond;
						},//
						null,//
						() -> staleEventsPerSecond.getCyclesPerSecond()),//

				new StatEntry(//
						INTERNAL_CATEGORY,//
						"staleEvTot",//
						"total number of stale events ever",//
						"%d",//
						null,//
						null,//
						null,//
						() -> platform.getHashgraph().getStaleEventsTotal()),//

				new StatEntry(//
						INTERNAL_CATEGORY,//
						"rescuedEv/sec",//
						"number of events per second generated to prevent stale events",//
						"%,16.2f",//
						rescuedEventsPerSecond,//
						(h) -> {
							rescuedEventsPerSecond = new StatsSpeedometer(h);
							return rescuedEventsPerSecond;
						},//
						null,//
						() -> rescuedEventsPerSecond.getCyclesPerSecond()),//

				new StatEntry(
						INTERNAL_CATEGORY,
						"DiskspaceFree",
						"disk space being used right now",
						"%d",
						null,
						null,
						null,
						() -> freeDiskspace),
				new StatEntry(
						INTERNAL_CATEGORY,
						"DiskspaceWhole",
						"total disk space available on node",
						"%d",
						null,
						null,
						null,
						() -> totalDiskspace),
				new StatEntry(
						INTERNAL_CATEGORY,
						"DiskspaceUsed",
						"disk space free for use by the node",
						"%d",
						null,
						null,
						null,
						() -> totalDiskspace - freeDiskspace),
				new StatEntry(//
						INFO_CATEGORY,//
						"eventStreamQueueSize",//
						"size of the queue from which we take events and write to EventStream file",//
						"%,13.0f",//
						eventStreamQueueSize,//
						(h) -> eventStreamQueueSize = new StatsRunningAverage(h),//
						null,//
						() -> eventStreamQueueSize.getWeightedMean()),
		};
		List<StatEntry> entryList = new ArrayList<>();
		entryList.addAll(Arrays.asList(statEntries));
		for (int i = 0; i < avgPingMilliseconds.length; i++) {
			final int ii = i; //make the current value of i into a constant inside each lambda generated here
			entryList.add(new StatEntry(
					PING_CATEGORY,//
					String.format("ping_ms_%02d", i),//
					String.format("milliseconds to send node %02d a byte and receive a reply", ii),//
					"%,4.2f",//
					avgPingMilliseconds[i] = new StatsRunningAverage(Settings.halfLife),//
					(h) -> (avgPingMilliseconds[ii] = new StatsRunningAverage(h)),//
					null,//
					() -> avgPingMilliseconds[ii].getWeightedMean()));
			avgPingMilliseconds[i] = new StatsRunningAverage(Settings.halfLife);
		}
		for (int i = 0; i < avgBytePerSecSent.length; i++) {
			final int ii = i; //make the current value of i into a constant inside each lambda generated here
			entryList.add(new StatEntry(
					BPSS_CATEGORY,//
					String.format("bytes/sec_sent_%02d", i),//
					String.format("bytes per second sent to node %02d", ii),//
					"%,16.2f",//
					avgBytePerSecSent[i] = new StatsSpeedometer(Settings.halfLife),//
					(h) -> (avgBytePerSecSent[ii] = new StatsSpeedometer(h)),//
					null,//
					() -> avgBytePerSecSent[ii].getCyclesPerSecond()));
		}
		statEntries = entryList.toArray(statEntries);
	}

	//
	// ConsensusStats below
	//

	/**
	 * Time when this platform received the first event created by someone else in the most recent round.
	 * This is used to calculate Statistics.avgFirstEventInRoundReceivedTime which is "time for event, from
	 * receiving the first event in a round to the first event in the next round".
	 */
	private volatile Instant firstEventInLastRoundTime = null;
	/** the max round number for which at least one event is known that was created by someone else */
	private volatile long lastRoundNumber = -1;

	@Override
	public void addedEvent(EventImpl event) {
		// this method is only ever called by 1 thread, so no need for locks
		if (!platform.getSelfId().equalsMain(event.getCreatorId())
				&& event.getRoundCreated() > lastRoundNumber) {// if first event in a round
			Instant now = Instant.now();
			if (firstEventInLastRoundTime != null) {
				avgFirstEventInRoundReceivedTime.recordValue(
						firstEventInLastRoundTime.until(now,
								ChronoUnit.NANOS) / 1_000_000_000.0);
			}
			firstEventInLastRoundTime = now;
			lastRoundNumber = event.getRoundCreated();
		}
	}

	@Override
	public void coinRounds(long numCoinRounds) {
		this.numCoinRounds.recordValue(numCoinRounds);
	}

	@Override
	public void lastFamousInRound(EventImpl event) {
		if (!platform.getSelfId().equalsMain(event.getCreatorId())) {// record this for events received
			avgReceivedFamousTime.recordValue(
					event.getTimeReceived().until(Instant.now(),
							ChronoUnit.NANOS) / 1_000_000_000.0);
		}
	}

	@Override
	public void consensusReached(EventImpl event) {
		// Keep a running average of how many seconds from when I first know of an event
		// until it achieves consensus. Actually, keep two such averages: one for events I
		// create, and one for events I receive.
		// Because of transThrottle, these statistics can end up being misleading, so we are only tracking events that
		// have user transactions in them.
		if (event.hasUserTransactions()) {
			if (platform.getSelfId().equalsMain(event.getCreatorId())) { // set either created or received time to now
				avgCreatedConsensusTime
						.recordValue(event.getTimeReceived().until(Instant.now(),
								ChronoUnit.NANOS) / 1_000_000_000.0);
			} else {
				avgReceivedConsensusTime
						.recordValue(event.getTimeReceived().until(Instant.now(),
								ChronoUnit.NANOS) / 1_000_000_000.0);
				avgCreatedReceivedConsensusTime
						.recordValue(event.getTimeCreated().until(Instant.now(),
								ChronoUnit.NANOS) / 1_000_000_000.0);
			}
		}

		// Because of transThrottle, these statistics can end up being misleading, so we are only tracking events that
		// have user transactions in them.
		if (event.hasUserTransactions()) {
			if (platform.getSelfId().equalsMain(event.getCreatorId())) {
				avgSelfCreatedTimestamp.recordValue(
						event.getTimeCreated().until(event.getConsensusTimestamp(),
								ChronoUnit.NANOS) / 1_000_000_000.0);
			} else {
				avgOtherReceivedTimestamp.recordValue(
						event.getTimeReceived().until(event.getConsensusTimestamp(),
								ChronoUnit.NANOS) / 1_000_000_000.0);
			}
		}
	}

	@Override
	public void consensusReachedOnRound() {
		roundsPerSecond.cycle();
	}

	@Override
	public void dotProductTime(long nanoTime) {
		timeFracDot.update(((double) nanoTime) / 1_000_000_000);
	}
}
